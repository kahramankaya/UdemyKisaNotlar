# pandas numpy e alternatif olarak doğmamıştır. numpy ile yapamadığımız bazı şeyleri pandas ile yapabiliyoruz. bu yüzden hem numpy hemde pandas ı bilmek lazım.

import pandas as pd
kaho=pd.Series([78,9,5,4,5,6,18,45,7,99,566])
print(kaho) # görüldüğü üzere veriler index bilgisi ile yazıldı.
print(kaho.axes) # [RangeIndex(start=0, stop=11, step=1)]görüldüğü üzere axes ile index bilgisine eriştik. 0 dan başlayarak 5 e kadar 5 dahıl değil. ve  bir bir atlayarak göstermiş.
print(kaho.size) # eleman sayısını verir.
print(kaho.ndim)
print(kaho.dtype)
print(kaho.values) # değerleri  gösterir.
print(kaho.head()) # burda parantz içinde herhangi bir sayı yok ise ilk 5 eleman gösterilir.
print(kaho.head(3)) # ilk 3 eleman yazdırılır.
print(kaho.tail()) # son bir kaç elemana gözatmak için tail kullanılır. zaten ingilizcede o anlama gelir.
kaho1=pd.Series([78,9,45,656,879,35],index=[1,2,3,4,5,6])
print(kaho1) # görüldüğü üzere indexleri kendimizde belirleyebiliyoruz.
kaho2=pd.Series([78,9,45,656,879,35],index=["k","a","h","r","a","m"])
print(kaho2) # indexleri sayı olmayacak şekilde de yapabiliriz bu şekilde ki gibi.
print(kaho2["m"]) # karşılığı olan 35 cıkar. sözlük yapısı gibi düşüm burayı.
print(kaho2["k":"h"]) # bu şekilde slice işlemi de yapılabilir.



#sözlük üzerinden liste oluşturmak
import pandas as pd
j=pd.Series({"fare":"kucuk","inek":"buyuk","keci":"orta"})
print(j)

# alt saturda concat fonksiyonu birleştirmeye yarar.
print(pd.concat([j,j])) 

# eleman işlemleri:
#aşagıdakı ıslemler sayesınde numpyı panasa cevırdık
import numpy as np
j2=np.array([3,4,5,8,89,6,5,4,34])
j3=pd.Series(j2)
print(j3)
# j.index indexleri verir.
print(j.index) # Index(['fare', 'inek', 'keci'], dtype='object')
print(j.values) # ['kucuk' 'buyuk' 'orta'] sadece değerlere ulaştık bu sayede.
print(list(j.items())) # [('fare', 'kucuk'), ('inek', 'buyuk'), ('keci', 'orta')] boylece elemanlara eriştik.








#sözlük üzerinden liste oluşturmak
import pandas as pd
j=pd.Series({"fare":"kucuk","inek":"buyuk","keci":"orta"})
print(j)

# alt saturda concat fonksiyonu birleştirmeye yarar.
print(pd.concat([j,j])) 

# eleman işlemleri:
#aşagıdakı ıslemler sayesınde numpyı panasa cevırdık
import numpy as np
j2=np.array([3,4,5,8,89,6,5,4,34])
j3=pd.Series(j2)
print(j3)
# j.index indexleri verir.
print(j.index) # Index(['fare', 'inek', 'keci'], dtype='object')
print(j.values) # ['kucuk' 'buyuk' 'orta'] sadece değerlere ulaştık bu sayede.
print(list(j.items())) # [('fare', 'kucuk'), ('inek', 'buyuk'), ('keci', 'orta')] boylece elemanlara eriştik.



# eleman sorgulama:
j2=np.array([3,4,5,8,89,6,5,4,34])
print(4 in j2)  # bu yapı soyle der: j2 içinde 4 var mı?
  

import pandas as pd
j=pd.Series({"fare":"kucuk","inek":"buyuk","keci":"orta"})
#asagıdakı satırda fancy ile elemanlara eriştik.
print(j[["fare","keci"]])






import pandas as pd
#Dataframe excel gibi düşünebilirsin. veriyi excel formatına dönüştürüyor.
j4=[5,521,321,5465,8968,43512,13,654,321,564]
j5=pd.DataFrame(j4)
print(j5)
print(pd.DataFrame(j4,columns=["kahraman"])) # columns yazarak değişken atabiliyoruz.


import numpy as np
j6=np.arange(0,20).reshape(5,4)
j7=pd.DataFrame(j6,columns=["a","b","c","d"])
print(j7) # sutunların ustune degiskenlerini atadık.

print(j7.head(3)) # ilk 3 tanesini gösterdim.
print(j7.tail(2))
print(j7.columns) # Index(['a', 'b', 'c', 'd'], dtype='object') burada sütunların üstündeki ni çağırdık.


j7.columns=["q","w","r","t"] # böylece üstünde kilerin isimlerideğiştirebildik
print(j7)
print(j7.axes) # [RangeIndex(start=0, stop=5, step=1), Index(['q', 'w', 'r', 't'], dtype='object')]
print(type(j7)) # <class 'pandas.core.frame.DataFrame'>
print(j7.shape) # (5, 4)
print(j7.values) # liste seklınde array cıktı. pekı j7.array type nedir asagıda kı satırda
print(type(j7.values)) # <class 'numpy.ndarray'> gordugun gıbı array oldugu ıcın pandas degıl numpy dedı.






# sozluk uzerınden DataFrame oluşturma.
import numpy as np
v1=np.random.randint(5,size=3)
v2=np.random.randint(6,size=3)
v3=np.random.randint(10,size=3)


sozluk={"bayram":v1,
        "kahraman":v2,
        "onurhan":v3}
pd=pd.DataFrame(sozluk)
print(pd)
print(pd[0:2])
print(pd.ndim)
print(pd.shape)
print(pd.size)


# asagıda kı satırlarda gorulecegı uzere bu sekılde ındex kısmını ıstedıgımız gıbı degıstırdık.
print(pd.index)
pd.index=[2,5,8]
print(pd)






# SATIR VE SÜTUN BAZINDA SİLME:
import pandas as pd
import numpy as np
v1=np.random.randint(5,size=3)
v2=np.random.randint(6,size=3)
v3=np.random.randint(10,size=3)
sozluk={"bayram":v1,
        "kahraman":v2,
        "onurhan":v3}

q=pd.DataFrame(sozluk, index=["a","b","c"])
print(q)
print(q.drop("kahraman",axis=1)) # sütun bazında kahramanın sütunu sildi goruldugu uzere.
print(q.drop("b",axis=0)) # axis sıfır ise satırdan silmeye başalr. axis 1 ise sütun olarak silme işlemi yapar. 
print(q.drop("c",axis=0))
#AMA YUKARDA YAPTIĞIMIZ KALICI SİLME İŞLEMLERİ DEĞİL. KALICI YAPMAK İSTİYORSAK İNSPLACE KULLANILIR.
print(q)
# print(q.drop("a",axis=0,inplace=True))
print(q) # görüldüğü üzere kalıcı silme işlemi yaptık. yukardaki satırla.

#diyelim ki aynı anda bır den cok ındexı sılmek ıstıyoruz. o zman fanc kullanmalıyız.
l=["bayram","onurhan"]
print(q.drop(l,axis=1)) # fancy ile silme işlemi yaptırdık. boylece coklu sutun slme ya da satır sılme işlemi yapılabılır.
print(q)


#değişken için sorgulama işlemleri:
# "?" in q dediğimiz zaman ? q içinde var mı diye somuş oluyoruz.
print("bayram" in q) # oldugu ıcın True dedi

kğ=["kahraman","bayram","onurhan","kaho"]
for m in kğ:
    print(m in q)


#╚değişken eklem dırek boyle olur. bakar eger o degısken yoksa dırek ekler.
q["mert"]=[4,5,6]
print(q)
q["kahraman"]=[1,2,3] #{ var olan değişkeni değişterebilirsin bu sayede.}
print(q)

#değişkene işlemler yapma:
khj=q["kahraman"]*q["onurhan"]
print(khj)








# loc and iloc:
import numpy as np
import pandas as pd
t1=np.random.randint(0,50,size=5)
t2=np.random.randint(100,200,size=5)
t3=np.random.randint(200,1000,size=(5))
t6=np.random.randint(2000,120000,size=(5))
t5=[t1,t2,t3,t6]
t4=pd.DataFrame(t5,columns=["a","b","c","d","e"],index=["x","y","z","t"])
print(t4)
# loc and iloc:
# loc: istedıgımız ındexı oraya kadar goturur.ama iloc ise sondan bır eksık. mesela her ıkısnıne [0:3] yazdım locta 0,1,2,3, cıkarken loc ta ıse 0,1,2 cıkar.
# loc veri yapında ki verdiğin index isimlerine göre giderken iloc ise ona bakmadan direk int ndex kullanır. yani sen indexe ne dersen de o kendi index sayacaına göre gidecektir.
print(t4.loc["x":,"c"])
print(t4.iloc[0:,2])
# eger ki iloc ile degısken ısmını yazarak yazdırmak ıstıyorsan alt satırıda kı yontemı kullan.
print(t4.iloc[0:]["c"])
print(t4.loc["x":"t"])
print(t4.iloc[0:3]) # 65 ve 66. satırlar aynı sonucu verir.
print(t4.loc["x":"z","a":"c"])
print(t4.iloc[0:2,0:4])







